{"ast":null,"code":"import { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n\nvar __DEV__ = \"development\" !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  return touch.timeStamp || touch.timestamp;\n}\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\nexport default ResponderTouchHistoryStore;","map":{"version":3,"sources":["C:\\projects\\portfolio\\experiment-1\\node_modules\\react-native-web\\dist\\modules\\useResponderEvents\\ResponderTouchHistoryStore.js"],"names":["isStartish","isMoveish","isEndish","__DEV__","MAX_TOUCH_BANK","touchBank","touchHistory","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","console","error","recordTouchStart","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","activeRecord"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\nexport default ResponderTouchHistoryStore;"]},"metadata":{},"sourceType":"module"}